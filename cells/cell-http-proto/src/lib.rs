//! RPC protocol for dodeca dev server cell
//!
//! Defines three RPC services:
//! - `ContentService`: Host implements, cell calls (for content from picante DB)
//! - `TcpTunnel`: Cell implements, host calls (for L4 TCP tunneling)
//! - `WebSocketTunnel`: Host implements, cell calls (for devtools WebSocket)
//!
//! # Method ID Generation
//!
//! Method IDs are automatically generated by rapace using FNV-1a hashes of
//! "ServiceName.method_name", ensuring globally unique IDs without collisions.

use facet::Facet;

// Re-export types from dodeca-protocol that are used in the RPC interface
pub use dodeca_protocol::{EvalResult, ScopeEntry, ScopeValue};

/// Handle returned when opening a TCP tunnel.
///
/// Contains the channel ID used for bidirectional streaming.
/// After `open()` returns, both host and cell use this channel_id
/// to send and receive raw TCP bytes via rapace tunnel APIs.
#[derive(Debug, Clone, PartialEq, Eq, Facet)]
pub struct TunnelHandle {
    /// The channel ID to use for tunnel data transfer.
    pub channel_id: u32,
}

/// TCP tunnel service implemented by the cell.
///
/// The host calls `open()` for each incoming browser TCP connection.
/// The cell connects to its internal HTTP server and bridges the tunnel.
///
/// Workflow:
/// 1. Host accepts TCP connection from browser
/// 2. Host calls `TcpTunnelClient::open()` via RPC
/// 3. Cell connects to its internal HTTP server (127.0.0.1:internal_port)
/// 4. Cell returns `TunnelHandle` with channel_id
/// 5. Both sides use rapace tunnel APIs to bridge:
///    - Host: browser TCP ↔ rapace chunks
///    - Cell: rapace chunks ↔ internal TCP
#[allow(async_fn_in_trait)]
#[rapace::service]
pub trait TcpTunnel {
    /// Open a new bidirectional TCP tunnel.
    ///
    /// Returns a handle containing the channel_id to use for data transfer.
    async fn open(&self) -> crate::TunnelHandle;
}

/// Content returned by the host for a given path
#[derive(Debug, Clone, Facet)]
#[repr(u8)]
pub enum ServeContent {
    /// HTML page content
    Html {
        content: String,
        route: String,
        generation: u64,
    },
    /// CSS stylesheet
    Css { content: String, generation: u64 },
    /// Static file with MIME type (immutable, cacheable)
    Static {
        content: Vec<u8>,
        mime: String,
        generation: u64,
    },
    /// Static file that should not be cached
    StaticNoCache {
        content: Vec<u8>,
        mime: String,
        generation: u64,
    },
    /// Search index file (pagefind)
    Search {
        content: Vec<u8>,
        mime: String,
        generation: u64,
    },
    /// Redirect to another URL (302 temporary redirect)
    Redirect { location: String, generation: u64 },
    /// Not found - rendered 404 HTML page
    NotFound { html: String, generation: u64 },
}

/// Content service provided by the host
///
/// The cell calls these methods to get content from the host's picante DB.
#[allow(async_fn_in_trait)]
#[rapace::service]
pub trait ContentService {
    /// Find content for a given path (HTML, CSS, static files, devtools assets)
    async fn find_content(&self, path: String) -> crate::ServeContent;

    /// Get scope entries for devtools (variable inspector)
    async fn get_scope(&self, route: String, path: Vec<String>) -> Vec<crate::ScopeEntry>;

    /// Evaluate an expression in the context of a route (REPL)
    async fn eval_expression(&self, route: String, expression: String) -> crate::EvalResult;
}

/// WebSocket tunnel service implemented by the host.
///
/// The cell calls `open()` when a browser opens a WebSocket connection
/// to the devtools endpoint (/_/ws). The host handles the devtools protocol
/// directly - the cell just pipes bytes.
///
/// Workflow:
/// 1. Browser opens WebSocket to cell at /_/ws
/// 2. Cell calls `WebSocketTunnelClient::open()` via RPC
/// 3. Host returns `TunnelHandle` with channel_id
/// 4. Cell bridges: WebSocket frames ↔ rapace tunnel chunks
/// 5. Host handles devtools protocol (get_scope, eval, reload broadcasts)
#[allow(async_fn_in_trait)]
#[rapace::service]
pub trait WebSocketTunnel {
    /// Open a new WebSocket tunnel to the host.
    ///
    /// Returns a handle containing the channel_id to use for data transfer.
    /// After this returns, the cell sends WebSocket frame bytes through the tunnel,
    /// and the host handles the devtools protocol.
    async fn open(&self) -> crate::TunnelHandle;
}
